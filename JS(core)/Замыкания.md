# Замыкания

**Замыкание** — это функция, которая "запоминает" свое лексическое окружение, даже когда выполняется вне него. Это позволяет функции иметь доступ к переменным из внешней функции после завершения ее выполнения.

---

## Что такое замыкание?

**Замыкание** в JavaScript — это функция, которая имеет доступ к:
1. Собственной области видимости.
2. Области видимости родительской функции.
3. Глобальной области видимости.

Даже после завершения выполнения родительской функции, замыкание "удерживает" доступ к этим переменным. Это делает замыкания удобным инструментом для сохранения состояния и работы с приватными переменными.

---

## Как работает замыкание?

Когда функция создается в JavaScript, она "запоминает" область видимости, в которой была объявлена. Эта область включает все переменные, определенные в функции и в ее родительских функциях. Замыкание продолжает "жить", даже если внешняя функция завершила выполнение.

#### Пример:
```javascript
function outerFunction() {
    let outerVariable = 'Я снаружи!';
    function innerFunction() {
        console.log(outerVariable); // Доступ к переменной outerVariable
    }
    return innerFunction;
}
const closure = outerFunction(); // outerFunction возвращает innerFunction
closure(); // 'Я снаружи!'
```

1. В `outerFunction` определяется переменная `outerVariable`.
2. Внутри нее объявлена функция `innerFunction`, которая использует `outerVariable`.
3. После вызова `outerFunction` она возвращает `innerFunction`.
4. Замыкание сохраняет доступ к `outerVariable`, даже после завершения `outerFunction`.

---

## Применение замыканий

### 1. **Создание приватных переменных**
Замыкания позволяют скрывать переменные от внешнего кода, предоставляя интерфейс для управления ими.

```javascript
function createCounter() {
    let count = 0; // Приватная переменная
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}
const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount());  // 2
console.log(counter.decrement()); // 1
```

---

### 2. **Функции обратного вызова (Callback)**
Замыкания позволяют передавать состояние в функцию обратного вызова.

```javascript
function makeCounter() {
    let count = 0;
    return function() {
        count++;
        return count;
    };
}
const counter1 = makeCounter();
const counter2 = makeCounter();

console.log(counter1()); // 1
console.log(counter1()); // 2
console.log(counter2()); // 1
```

---

### 3. **Модули**
Замыкания используются для создания модулей, которые инкапсулируют внутренние данные.

```javascript
const myModule = (function() {
    let privateVar = 'Я приватный!';
    return {
        getPrivateVar: function() {
            return privateVar;
        }
    };
})();
console.log(myModule.getPrivateVar()); // 'Я приватный!'
// console.log(myModule.privateVar); // undefined
```

---

## Итог

**Замыкания** в JavaScript — это мощный инструмент для управления состоянием и инкапсуляции данных. Они позволяют создавать приватные переменные, сохранять данные между вызовами функций и использовать сложные конструкции, такие как модули или функции обратного вызова. Замыкания — это фундаментальная концепция, которая помогает решать широкий спектр задач в веб-разработке.

--- 

## ЗАДАЧИ
Вот несколько задач для закрепления знаний о **замыканиях**:

---

### Задача 1: Базовое замыкание
Что выведет следующий код? Объясните почему.

```javascript
function outer() {
    let count = 0;
    return function() {
        count++;
        console.log(count);
    };
}

const increment = outer();
increment(); // ?
increment(); // ?
increment(); // ?
```

---

### Задача 2: Несколько замыканий
Что выведется в консоль?

```javascript
function createFunction() {
    let value = 'Замыкание!';
    return function() {
        console.log(value);
    };
}

const func1 = createFunction();
const func2 = createFunction();

func1(); // ?
func2(); // ?
```

---

### Задача 3: Приватные переменные
Реализуйте функцию `createBankAccount`, которая создает объект банковского счета с приватным балансом и методами для снятия, пополнения и проверки баланса.

```javascript
function createBankAccount(initialBalance) {
    // Реализуйте логику
}

const myAccount = createBankAccount(100);
console.log(myAccount.getBalance()); // 100
myAccount.deposit(50);
console.log(myAccount.getBalance()); // 150
myAccount.withdraw(70);
console.log(myAccount.getBalance()); // 80
myAccount.withdraw(200); // Недостаточно средств
```

---

### Задача 4: Потеря контекста
Что произойдет в следующем коде? Как исправить его, чтобы код работал правильно?

```javascript
function makeTimer() {
    let count = 0;
    return function() {
        count++;
        console.log(`Таймер: ${count} секунд прошло`);
    };
}

const timer = makeTimer();
setTimeout(timer, 1000); // ?
setTimeout(timer, 2000); // ?
setTimeout(timer, 3000); // ?
```

---

### Задача 5: Замыкания и циклы
Объясните, почему следующий код работает не так, как ожидается, и исправьте его.

```javascript
function createButtons() {
    for (var i = 0; i < 3; i++) {
        setTimeout(function() {
            console.log(`Нажата кнопка ${i}`);
        }, i * 1000);
    }
}

createButtons();
```

---

### Задача 6: Сохранение состояния
Реализуйте функцию, которая будет возвращать функцию для вычисления суммы всех переданных ей чисел. Каждая новая передача числа должна накапливать результат.

```javascript
function createSum() {
    // Реализуйте логику
}

const sum = createSum();
console.log(sum(5));  // 5
console.log(sum(3));  // 8
console.log(sum(10)); // 18
```

---

### Задача 7: Модули и замыкания
Реализуйте модуль для управления списком задач. У модуля должны быть следующие методы:
1. `addTask(task)` — добавляет задачу.
2. `removeTask(task)` — удаляет задачу.
3. `getTasks()` — возвращает все задачи.

```javascript
const taskManager = (function() {
    // Реализуйте логику
})();

taskManager.addTask('Выучить замыкания');
taskManager.addTask('Решить задачи');
console.log(taskManager.getTasks()); // ['Выучить замыкания', 'Решить задачи']
taskManager.removeTask('Выучить замыкания');
console.log(taskManager.getTasks()); // ['Решить задачи']
```

---

### Задача 8: Глобальная переменная против замыкания
Определите, что выведет следующий код, и объясните разницу между использованием замыканий и глобальной переменной.

```javascript
let count = 0;

function incrementGlobal() {
    count++;
    console.log(count);
}

function incrementClosure() {
    let count = 0;
    return function() {
        count++;
        console.log(count);
    };
}

incrementGlobal(); // ?
incrementGlobal(); // ?

const incrementLocal = incrementClosure();
incrementLocal(); // ?
incrementLocal(); // ?
```

---

Эти задачи помогут лучше понять, как работают замыкания, их применение и как они могут быть использованы для решения практических задач.

---
